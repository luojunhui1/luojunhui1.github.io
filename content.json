{"pages":[{"title":"关于","text":"我是谁 西南交通大学信息科学与技术学院计算机专业学生 罗俊辉 西南交通大学学生会 青年之声工作站前部长 西南交通大学 ROBOMASTER Heilos 战队视觉组成员 我会啥 简单的C++ 简单的Matlab 简单的Python 简单的视觉处理 不会算法 联系我？ QQ: 2479694366","link":"/About/index.html"}],"posts":[{"title":"欢迎来到我的博客","text":"","link":"/index/"},{"title":"Image Preprocessing","text":"噪声处理一般而言，我们将噪声分为以下几类 噪声类别 椒盐噪声 加性噪声 乘性噪声 高斯噪声 椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。 加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 图像去噪的方法有很多种，其中均值滤波、中值滤波、高斯滤波等比较基础且成熟，还有一些基于数学中偏微分方程的去噪方法，基于频域的小波去噪方法。中值滤波，均值滤波以其快速、稳定的特性，应用最为广泛，在OpenCV库中也直接提供了方法。 滤波的计算原理也比较容易理解，这里就不做过多介绍，放上一张效果图说明即可。 实际上，对于噪声的去噪处理实际上很多时候是一种模糊处理，这点从OpenCV中函数的命名就可以看出来，去噪让图片更平滑之外，也损失了一些信息，不过我们一般认为损失的信息无足轻重，而平滑更利于之后的特征提取等操作。 图像增强图像增强有以下两类： 图像增强方法 频域法 空间域法 频域法， 顾名思义，频域法就是把图像从空间域利用傅立叶、小波变换等算法把图像从空间域转化成频域，也就是把图像矩阵转化成二维信号，进而使用高通滤波或低通滤波器对信号进行过滤。采用低通滤波器（即只让低频信号通过）法，可去掉图中的噪声；采用高通滤波法，则可增强边缘等高频信号，使模糊的图片变得清晰。 空间域方法主要包括以下两种常用方法： 空间域方法 直方图均衡化 滤波 关于直方图均衡化能增强图像的原理，在博客 https://blog.csdn.net/weixin_38705903/article/details/88584181 中有详细说明。 基于滤波的方法主要有： 滤波 均值滤波 中值滤波 高斯滤波 图像分割图像分割是把图像分成若干个独立子区域的技术和过程，在计算机视觉的应用，我们关注的可以粗略的分为目标和前景，他们对应图像中特定的、具有独特性质的区域。为分割目标，我们需要将这些区域提取出来，这样才能进行如特征提取、目标识别等进一步的操作。 图像分割可分为这两个类别： 类别 非语义分割 语义分割 非语义分割分为以下几种类别： 非语义分割技术 说明 阈值分割 例如OpenCV中的二值化函数 区域分割 代表性的算法有两种：区域生长和区域分裂合并 聚类 利用样本的相似性，把相似的像素点聚合成同一个子区域 边缘分割 图像在边缘处灰度级会发生突变来对图像进行分割 直方图 通过统计图像中的像素，得到图像的灰度直方图，然后在直方图的波峰和波谷是用于定位图像中的簇 水平集 这个比较复杂，会额外写博客解释 区域生长代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940cv::Mat MainWindow::regionGrowFast(const cv::Mat &amp;src, const cv::Point2i seed, int throld){ //convert src to gray for getting gray value of every pixel cv::Mat gray; cv::cvtColor(src,gray, cv::COLOR_RGB2GRAY); // set every pixel to black cv::Mat result = cv::Mat::zeros(src.size(), CV_8UC1); if((seed.x &lt; 0) || (seed.y &lt; 0)) return result; result.at&lt;uchar&gt;(seed.y, seed.x) = 255; //gray value of seed int seed_gray = gray.at&lt;uchar&gt;(seed.y, seed.x); //grow direction sequenc int grow_direction[8][2] = {{-1,-1}, {0,-1}, {1,-1}, {1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}}; //seeds collection std::vector&lt;cv::Point2i&gt; seeds; seeds.push_back(seed); //start growing while(! seeds.empty()){ //get a seed cv::Point2i current_seed = seeds.back(); seeds.pop_back(); for(int i = 0; i &lt; 8; ++i){ cv::Point2i neighbor_seed(current_seed.x + grow_direction[i][0], current_seed.y + grow_direction[i][1]); //check wether in image if(neighbor_seed.x &lt; 0 || neighbor_seed.y &lt; 0 || neighbor_seed.x &gt; (gray.cols-1) || (neighbor_seed.y &gt; gray.rows -1)) continue; int value = gray.at&lt;uchar&gt;(neighbor_seed.y, neighbor_seed.x); if((result.at&lt;uchar&gt;(neighbor_seed.y, neighbor_seed.x) == 0) &amp;&amp; (abs(value - seed_gray) &lt;= throld)){ result.at&lt;uchar&gt;(neighbor_seed.y, neighbor_seed.x) = 255; seeds.push_back(neighbor_seed); } } } return result;} 区域分割代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;Eigen/Core&gt;#include &lt;Eigen/Dense&gt;#include &lt;opencv2/core/eigen.hpp&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;using namespace cv;using namespace Eigen;Mat src;Mat result;vector&lt;Rect&gt; rectToDepart;vector&lt;Rect&gt; resultRect;bool isDepart(Rect rect){ MatrixXf matrix; cv2eigen(src(rect), matrix); //cout &lt;&lt; matrix.mean() &lt;&lt;&quot;,&quot;&lt;&lt; rect.width&lt;&lt; &quot;,&quot;&lt;&lt;rect.height&lt;&lt;endl; MatrixXf averageRect = MatrixXf::Constant(rect.height, rect.width, matrix.mean()); MatrixXf subm = averageRect - matrix; long coff = ((subm.array() * subm.array()).sum()); if (coff &gt; 1000|| coff&lt;0)return true; return false;}bool Depart(Rect&amp; rect){ if (rect.width&lt;5||rect.height&lt;5 || !isDepart(rect)) { rectangle(result, rect, Scalar(255)); resultRect.push_back(rect); return false; } Mat cur = src(rect); int rectX = rect.x; int rectY = rect.y; int rectHalfWidth = (int)rect.width / 2; int rectHalfHeight = (int)rect.height / 2; rectToDepart.push_back(Rect(rectX, rectY, rectHalfWidth, rectHalfHeight)); rectToDepart.push_back(Rect(rectX + rectHalfWidth, rectY, rect.width - rectHalfWidth, rectHalfHeight)); rectToDepart.push_back(Rect(rectX, rectY + rectHalfHeight, rectHalfWidth, rect.height - rectHalfHeight)); rectToDepart.push_back(Rect(rectX + rectHalfWidth, rectY + rectHalfHeight, rect.width - rectHalfWidth, rect.height - rectHalfHeight)); return true;}int main(){ src = imread(&quot;1.jpg&quot;,IMREAD_GRAYSCALE); result = Mat(src.size(), CV_8UC1,Scalar(0)); Rect src_rect = Rect(0, 0, src.cols, src.rows); Rect cur_rect; Depart(src_rect); while (!rectToDepart.empty()) { cur_rect = rectToDepart.back(); rectToDepart.pop_back(); Depart(cur_rect); } while (1) { imshow(&quot;gray&quot;, src); imshow(&quot;depart&quot;, result); waitKey(30); } return 0;} 图像增广 图像增广（image augmentation）技术通过对训练图像做一系列随机改变，来产生相似但又不同的训练样本，从而扩大训练数据集的规模。图像增广的另一种解释是，随机改变训练样本可以降低模型对某些属性的依赖，从而提高模型的泛化能力。 目前常用的图像增广技术有如下几种： 图像增广技术 镜像变换 旋转 裁剪 平移 亮度修改 添加噪声 剪切 变换颜色 这些概念的理解比较简单，具体实现在OpenCV库中也有对应的函数可使用，就不详细说明，有兴趣的可以自行去其他地方查阅。","link":"/ImagePreprocessing/"},{"title":"算法","text":"","link":"/AL_index/"},{"title":"C Plus","text":"","link":"/cplus_index/"},{"title":"数据库_并发","text":"事务并发的可串行化 事务的串行执行（serial execution）:DBMS按顺序一次执行一个事务，各个事务之间没有交错。 事务的并行执行（concurrent execution）:DBMS同时执行多个事务，DBMS对各事务的操作进行调度，另其交错执行。 事务并发执行的好处： 改善系统资源利用率 改善短事务响应时间 事务并发执行可能产生的问题： 多个事务同时存取数据库中统一数据可能会引起·数据的读写冲突，对数据库的一致性造成破坏。 调度的要求： 一个事务的操作在调度中的顺序应与它们在事务中的顺序一致。 事务如不加控制地并发执行，可能会产生以下三个问题： 不加控制的并发执行可能产生的问题 类型 丢失更新 写写冲突 读脏数据 写读冲突 读值不可复现 读写冲突 ​ 丢失更新图例 ​ 读脏数据图例 ​ 读值不可复现图例 由以上三个可能出现的问题得出结论： 把不同事物中对同一对象进行WW\\RW\\WR操作进行交错时都会造成冲突，因此，在安排事务的交错（并发执行）时，应避免将其放在一起。 并发执行的串行化准则 并发原则：既要交错执行，以充分利用系统资源，加快短事务响应时间，又要避免访问冲突。 事物调度原则：调度中，不同事务的操作可以交错，同一事务的操作需保持相对顺序不变。 可串行化的两个要点： 关心对数据库的读写操作 目的是研究如何形成一个可串行化的并发调度，即“等价于”一个串行调度的并发调度。 前趋图：前趋图是一有向图G=(V,E)，V为顶点集合，表示所有参与调度的事物，E可通过分析冲突操作来决定。以下是示例： 事务集：{T1, T2, T3, T4} S= $$W_{T3}(y)R_{T1}(x)R_{T2}(y)W_{T3}(x)W_{T2}(x)W_{T3}(z)R_{T4}(z)W_{T4}(x)$$ $$R_{T2}(y)$$与$$W_{T3}(y)$$有写读冲突（读脏数据），画一条由点T3指向T2的有向边。 $$W_{T2}(x)$$与$$R_{T1}(x)$$有读写冲突，画一条由点T1指向T3的有向边。 $$W_{T2}(x)$$与$$R_{T1}(x)$$和$$W_{T3}(x)$$分别有冲突，画一条由点T3指向T2的有向边和T1指向T2的有向边。 以此类推，最终得到图如下： 判断是否可串行化：若前趋图有回路，则不可串行化；若没有回路，则可以串行化。 寻找等价串行调度方法：先执行入度为0的节点（事务），再将该节点（事务）及其相连边从前趋图中删除，再寻找入读为0的节点（事务）执行，反复如此，直到事务全部执行完毕。 基于锁的并发控制在实际运用中，用前面提到的方法来先验事务的可串行化并生成对应的事务执行顺序是不现实的。主要原因有以下两点： 事务集随机，不固定 不可能实现定好调度 并发控制通常的实现方法：不关心具体的调度，由DBMS制定号=好一个协议，按此协议执行事务，即可保证事务的可串行化。 加锁协议（Locking Protocol）:是上面所说的协议的一种，利用加锁实现并发控制，即在操作前对操作对象加锁。 加锁协议类型 特性 X锁（排他锁） 可读可写，其他事物不可对被加锁的数据操作，直到X锁被释放。避免了所有类型的冲突，但降低了并发度。 两阶段加锁协议（2PL协议） 所有加锁都在释放锁之前。若所有事物都遵循该协议，则它们的任何调度都是可串行化的。 （S,X）锁 与X锁相比，多了一条S锁与S锁相容，提高了并发度。 （S,U,X）锁 数据对象加了U锁后仍可被加S锁，只在最后写入时，将U锁升级为X锁。相比于X（S,X）锁，又进一步提高了并发度。 多粒度加锁或封锁 数据对象的大小可以是一张表，也可以是一个元组。 级联回退：即一事务还未结束就把锁释放了，又由于其他原因，该事务需要回退，为避免其它事务督导脏数据，要求读了和对该数据更新的操作也回退。在X锁，（S,X）锁，（S,U,X）锁中均存在该问题。 加锁协议补丁1：为避免级联回退，不管是写操作锁还是读操作锁，都应该保持到事务结束才释放。该补丁对其后的加锁协议也适用。 活锁：在（S,X）锁中，若一个数据对象被加S锁，此时若有其它事务对其加S锁，则根据相容矩阵，应该被允许，此时若有事务欲对该数据加X锁，则此X锁会被不断推迟。 加锁协议补丁2：先申请先服务，避免活锁现象造成响应时间过长，影响体验。 粒度、控制和并发度的关系：粒度越大，控制越简单，并发度越低。 多粒度加锁-锁冲突检测问题： 显式加锁：自身被加锁 隐式加锁：上级被加锁 过程： 检查本身，有无显式锁与本事务显式锁冲突。 检查其所有祖先，以防本事务显式锁与其他事务隐式锁冲突。 检查其所有子孙，以防本事务隐式锁与其他事务显式锁冲突。 简化锁冲突的检测： 三种意向锁 意向共享锁（IS锁） 意向排他锁（IX锁） 加锁时，对祖先按自上而下的顺序加意向锁。 解锁时，按自下而上的次序解锁。 死锁检测与预防死锁：当事务出现循环等待时，若不加以干预，则会一直等待下去，形成死锁。 对付死锁的两个办法： 防止死锁 检测死锁，发现死锁后处理死锁。 预防死锁的方法： ​ 给每个事务以时间戳先后为准设立优先级，时间戳越前，事务优先级越高。若有A事务持有资源Z的锁，而B事务申请对Z的锁。若A优先级更高，则B等待；若B优先级更高，则A回滚，再重启事务A并继承A回滚前的时间戳。 检测死锁的方法： 超时法 等待图法 死锁处理的方法： 处理思想：杀死事务，打破循环等待 选择牺牲事务的标准： 选择最迟交付的 选择获得锁最少的 选择回退代价最小的 不同DBMS的标准可能不一样。 被杀死事务的处理方法： 告知用户事务因死锁被杀死，稍后再次向系统交付该事务 由DBMS重启该事务。 不管哪种处理方式，被杀死的事务都要等待一段时间才能被重新执行，否则可能会再次引起死锁。 附图","link":"/%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%B9%B6%E5%8F%91/"},{"title":"水平集算法(level-set)","text":"显式轮廓法在说 level set 之前，我们先谈曲线的演变。假设我们现在有一条曲线如下，为知道这条曲线接下来的演化方向，我们需要知道这条曲线上每个点的运动方向和大小，这样就能确定曲线在下一时间点的轮廓。对于这条曲线来说，这可能并不难，但对于更加一般的情况来说，可能会出现以下几个问题： 显式轮廓法的缺陷 演化过程中轮廓可能需要插值增加轮廓点，或者减少轮廓点，实际应用比较麻烦 轮廓在演化过程中可能会出现分裂，合并的情况，而这在二维函数上难以处理 上面的这种方法很直观，但实现起来困难重重。为解决这两个问题，有人提出了隐式轮廓法。 隐式轮廓法隐函数为理解隐式轮廓法，首先要了解隐函数。我们要描述直线上的两个点，那么可以直接就写出两个点的坐标： 你也可以绕一下，写成集合的形式，也就是所谓的 level set： 这里的 y 的取值就是 level，那么和上面相比，直接是X 轴上的两个点。在这里的话，表达方式就成了，level 为1 的所有x取值的集合。 对于曲线来说，和上面的例子类似，不过曲线是二维的，它可以表示为f(x,y) = 0,于是，曲线的演化可以转化成曲面的演化，而曲面的演化导致了level = 0的曲线的演化。接下来，我们说的就是曲面的演化。 演化一个表面S，而不是一条曲线C，且我们用隐式轮廓法得到的轮廓的定义为这个表面S在高度h=0的所有点构成的集合。于是根据定义，水前曲线就是零水平集φ=0。如下图所示，是从一个演化的表面得到轮廓。以下是演化表面轮廓的过程。 可以看到，在初始时t=0,水平集的轮廓为一个矩形；在t=50的时候，轮廓由3个闭环开始合并为一个闭环，而在t=52时，轮廓结束了合并；在t=90时，轮廓开始分类，t=120时轮廓结束分裂。 水平集方程前面的部分都是直观地介绍一下大致原理，接下来就是玄学的数学理解过程。对于平面上的一个点来说，我们可以这样表示x = (x,y),那么点x属于一个随时间演化的曲线x(t)，而对于x(t)来说，它也会随时间变化，我们将x(t)随t的变化表示成一个新的函数：$\\phi(x(t),t)$,并且定义我们的轮廓就在$\\phi(x(t),t)$ = 0的平面上。 那么什么是$\\phi(x(t),t)$呢，事实上，任何符合$\\phi(x(t),t)$ = 0的曲线和我们的初始轮廓相同的$\\phi(x(t),t)$都可以。 在时刻t=0处，给定初始函数$\\phi$，根据运动方程∂s/∂t我们可以得到任意t时刻的s。对于此，利用链式法则，有： 把$\\frac{\\partial\\phi}{\\partial x}$记作$\\nabla \\phi$,$x_t$ 的方向由表面的法向量给定 ，因此$ x_t = F(x)\\vec{n},\\vec{n} = {\\nabla\\phi \\over{\\phi}}$ 上面的运动方程刻重写为： 最后一个方程定义了φ的运动。给定t=0时的φ以及它随时间演化的运动方程，我们可以通过演化初始函数 $\\phi(x,y,t = 0)$ 得知任何t时刻的 $\\phi(x,y,t)$, 样我们就回答了最初的问题，即我们知道了$\\phi $是什么。 这样我们就回答了最初的问题，即我们知道了$\\phi$是什么。 $\\phi $有个有趣的特征，就是我们可以用下式得到表面的曲率： 我们可以用它来控制平滑度。 说实话，没看懂，看懂了再写。 老翻译家了，这个资料太少了，YouTube上有讲解视频，但那英语真难顶。 参考资源 https://profs.etsmtl.ca/hlombaert/levelset/#fig:levelset-square https://www.cnblogs.com/hyb221512/p/9415995.html 水平集——那些我膜拜过的牛人2[链接实在太长] https://www.zhihu.com/question/22608763","link":"/%E6%B0%B4%E5%B9%B3%E9%9B%86%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"CV","slug":"CV","link":"/tags/CV/"},{"name":"Image","slug":"Image","link":"/tags/Image/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"图像分割","slug":"图像分割","link":"/tags/%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2/"}],"categories":[{"name":"Vision","slug":"Vision","link":"/categories/Vision/"},{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"CPlus","slug":"CPlus","link":"/categories/CPlus/"}]}