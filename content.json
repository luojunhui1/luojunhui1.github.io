{"pages":[{"title":"算法","text":"","link":"/Algorithm/index.html"},{"title":"C++","text":"","link":"/C++/index.html"},{"title":"Study","text":"[","link":"/Study/index.html"},{"title":"数据库库_并发","text":"[数据库学习-并发]并发控制事务并发的可串行化 事务的串行执行（serial execution）:DBMS按顺序一次执行一个事务，各个事务之间没有交错。 事务的并行执行（concurrent execution）:DBMS同时执行多个事务，DBMS对各事务的操作进行调度，另其交错执行。 事务并发执行的好处： 改善系统资源利用率 改善短事务响应时间 事务并发执行可能产生的问题： 多个事务同时存取数据库中统一数据可能会引起·数据的读写冲突，对数据库的一致性造成破坏。 调度的要求： 一个事务的操作在调度中的顺序应与它们在事务中的顺序一致。 事务如不加控制地并发执行，可能会产生以下三个问题： 不加控制的并发执行可能产生的问题 类型 丢失更新 写写冲突 读脏数据 写读冲突 读值不可复现 读写冲突 ​ 丢失更新图例 ​ 读脏数据图例 ​ 读值不可复现图例 由以上三个可能出现的问题得出结论： 把不同事物中对同一对象进行WW\\RW\\WR操作进行交错时都会造成冲突，因此，在安排事务的交错（并发执行）时，应避免将其放在一起。 并发执行的串行化准则 并发原则：既要交错执行，以充分利用系统资源，加快短事务响应时间，又要避免访问冲突。 事物调度原则：调度中，不同事务的操作可以交错，同一事务的操作需保持相对顺序不变。 可串行化的两个要点： 关心对数据库的读写操作 目的是研究如何形成一个可串行化的并发调度，即“等价于”一个串行调度的并发调度。 前趋图：前趋图是一有向图G=(V,E)，V为顶点集合，表示所有参与调度的事物，E可通过分析冲突操作来决定。以下是示例： 事务集：{T1, T2, T3, T4} S= $$W_{T3}(y)R_{T1}(x)R_{T2}(y)W_{T3}(x)W_{T2}(x)W_{T3}(z)R_{T4}(z)W_{T4}(x)$$ $$R_{T2}(y)$$与$$W_{T3}(y)$$有写读冲突（读脏数据），画一条由点T3指向T2的有向边。 $$W_{T2}(x)$$与$$R_{T1}(x)$$有读写冲突，画一条由点T1指向T3的有向边。 $$W_{T2}(x)$$与$$R_{T1}(x)$$和$$W_{T3}(x)$$分别有冲突，画一条由点T3指向T2的有向边和T1指向T2的有向边。 以此类推，最终得到图如下： 判断是否可串行化：若前趋图有回路，则不可串行化；若没有回路，则可以串行化。 寻找等价串行调度方法：先执行入度为0的节点（事务），再将该节点（事务）及其相连边从前趋图中删除，再寻找入读为0的节点（事务）执行，反复如此，直到事务全部执行完毕。 基于锁的并发控制在实际运用中，用前面提到的方法来先验事务的可串行化并生成对应的事务执行顺序是不现实的。主要原因有以下两点： 事务集随机，不固定 不可能实现定好调度 并发控制通常的实现方法：不关心具体的调度，由DBMS制定号=好一个协议，按此协议执行事务，即可保证事务的可串行化。 加锁协议（Locking Protocol）:是上面所说的协议的一种，利用加锁实现并发控制，即在操作前对操作对象加锁。 加锁协议类型 特性 X锁（排他锁） 可读可写，其他事物不可对被加锁的数据操作，直到X锁被释放。避免了所有类型的冲突，但降低了并发度。 两阶段加锁协议（2PL协议） 所有加锁都在释放锁之前。若所有事物都遵循该协议，则它们的任何调度都是可串行化的。 （S,X）锁 与X锁相比，多了一条S锁与S锁相容，提高了并发度。 （S,U,X）锁 数据对象加了U锁后仍可被加S锁，只在最后写入时，将U锁升级为X锁。相比于X（S,X）锁，又进一步提高了并发度。 多粒度加锁或封锁 数据对象的大小可以是一张表，也可以是一个元组。 级联回退：即一事务还未结束就把锁释放了，又由于其他原因，该事务需要回退，为避免其它事务督导脏数据，要求读了和对该数据更新的操作也回退。在X锁，（S,X）锁，（S,U,X）锁中均存在该问题。 加锁协议补丁1：为避免级联回退，不管是写操作锁还是读操作锁，都应该保持到事务结束才释放。该补丁对其后的加锁协议也适用。 活锁：在（S,X）锁中，若一个数据对象被加S锁，此时若有其它事务对其加S锁，则根据相容矩阵，应该被允许，此时若有事务欲对该数据加X锁，则此X锁会被不断推迟。 加锁协议补丁2：先申请先服务，避免活锁现象造成响应时间过长，影响体验。 粒度、控制和并发度的关系：粒度越大，控制越简单，并发度越低。 多粒度加锁-锁冲突检测问题： 显式加锁：自身被加锁 隐式加锁：上级被加锁 过程： 检查本身，有无显式锁与本事务显式锁冲突。 检查其所有祖先，以防本事务显式锁与其他事务隐式锁冲突。 检查其所有子孙，以防本事务隐式锁与其他事务显式锁冲突。 简化锁冲突的检测： 三种意向锁 意向共享锁（IS锁） 意向排他锁（IX锁） 加锁时，对祖先按自上而下的顺序加意向锁。 解锁时，按自下而上的次序解锁。","link":"/Study/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%93-%E5%B9%B6%E5%8F%91.html"},{"title":"ImagePreprocessing","text":"图像预处理OpenCV图像预处理噪声处理一般而言，我们将噪声分为以下几类 噪声类别 椒盐噪声 加性噪声 乘性噪声 高斯噪声 椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。 加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 图像去噪的方法有很多种，其中均值滤波、中值滤波、高斯滤波等比较基础且成熟，还有一些基于数学中偏微分方程的去噪方法，基于频域的小波去噪方法。中值滤波，均值滤波以其快速、稳定的特性，应用最为广泛，在OpenCV库中也直接提供了方法。 滤波的计算原理也比较容易理解，这里就不做过多介绍，放上一张效果图说明即可。 实际上，对于噪声的去噪处理实际上很多时候是一种模糊处理，这点从OpenCV中函数的命名就可以看出来，去噪让图片更平滑之外，也损失了一些信息，不过我们一般认为损失的信息无足轻重，而平滑更利于之后的特征提取等操作。 图像增强图像增强有以下两类： 图像增强方法 频域法 空间域法 频域法， 顾名思义，频域法就是把图像从空域利用傅立叶、小波变换等算法把图像从空间域转化成频域，也就是把图像矩阵转化成二维信号，进而使用高通滤波或低通滤波器对信号进行过滤。采用低通滤波器（即只让低频信号通过）法，可去掉图中的噪声；采用高通滤波法，则可增强边缘等高频信号，使模糊的图片变得清晰。 空域方法主要包括以下两种常用方法： 空域方法 直方图均衡化 滤波 关于直方图均衡化能增强图像的原理，在博客 https://blog.csdn.net/weixin_38705903/article/details/88584181 中有详细说明。 图像分割图像增广神经网络图像预处理特定应用场景下的预处理","link":"/Vision/ImagePreprocessing.html"},{"title":"Vision","text":"","link":"/Vision/index.html"}],"posts":[{"title":"ImagePreprocessing","text":"图像预处理OpenCV图像预处理噪声处理一般而言，我们将噪声分为以下几类 噪声类别 椒盐噪声 加性噪声 乘性噪声 高斯噪声 椒盐噪声也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素（或是两者皆有）。 加性噪声一般指热噪声、散弹噪声等，它们与信号的关系是相加，不管有没有信号，噪声都存在。 而乘性噪声一般由信道不理想引起，它们与信号的关系是相乘，信号在它在，信号不在他也就不在。 图像去噪的方法有很多种，其中均值滤波、中值滤波、高斯滤波等比较基础且成熟，还有一些基于数学中偏微分方程的去噪方法，基于频域的小波去噪方法。中值滤波，均值滤波以其快速、稳定的特性，应用最为广泛，在OpenCV库中也直接提供了方法。 滤波的计算原理也比较容易理解，这里就不做过多介绍，放上一张效果图说明即可。 实际上，对于噪声的去噪处理实际上很多时候是一种模糊处理，这点从OpenCV中函数的命名就可以看出来，去噪让图片更平滑之外，也损失了一些信息，不过我们一般认为损失的信息无足轻重，而平滑更利于之后的特征提取等操作。 图像增强图像增强有以下两类： 图像增强方法 频域法 空间域法 频域法， 顾名思义，频域法就是把图像从空域利用傅立叶、小波变换等算法把图像从空间域转化成频域，也就是把图像矩阵转化成二维信号，进而使用高通滤波或低通滤波器对信号进行过滤。采用低通滤波器（即只让低频信号通过）法，可去掉图中的噪声；采用高通滤波法，则可增强边缘等高频信号，使模糊的图片变得清晰。 空域方法主要包括以下两种常用方法： 空域方法 直方图均衡化 滤波 关于直方图均衡化能增强图像的原理，在博客 https://blog.csdn.net/weixin_38705903/article/details/88584181 中有详细说明。 图像分割图像增广神经网络图像预处理特定应用场景下的预处理","link":"/ImagePreprocessing/"},{"title":"欢迎来到我的博客","text":"[","link":"/index/"},{"title":"数据库库_并发","text":"[数据库学习-并发]并发控制事务并发的可串行化 事务的串行执行（serial execution）:DBMS按顺序一次执行一个事务，各个事务之间没有交错。 事务的并行执行（concurrent execution）:DBMS同时执行多个事务，DBMS对各事务的操作进行调度，另其交错执行。 事务并发执行的好处： 改善系统资源利用率 改善短事务响应时间 事务并发执行可能产生的问题： 多个事务同时存取数据库中统一数据可能会引起·数据的读写冲突，对数据库的一致性造成破坏。 调度的要求： 一个事务的操作在调度中的顺序应与它们在事务中的顺序一致。 事务如不加控制地并发执行，可能会产生以下三个问题： 不加控制的并发执行可能产生的问题 类型 丢失更新 写写冲突 读脏数据 写读冲突 读值不可复现 读写冲突 ​ 丢失更新图例 ​ 读脏数据图例 ​ 读值不可复现图例 由以上三个可能出现的问题得出结论： 把不同事物中对同一对象进行WW\\RW\\WR操作进行交错时都会造成冲突，因此，在安排事务的交错（并发执行）时，应避免将其放在一起。 并发执行的串行化准则 并发原则：既要交错执行，以充分利用系统资源，加快短事务响应时间，又要避免访问冲突。 事物调度原则：调度中，不同事务的操作可以交错，同一事务的操作需保持相对顺序不变。 可串行化的两个要点： 关心对数据库的读写操作 目的是研究如何形成一个可串行化的并发调度，即“等价于”一个串行调度的并发调度。 前趋图：前趋图是一有向图G=(V,E)，V为顶点集合，表示所有参与调度的事物，E可通过分析冲突操作来决定。以下是示例： 事务集：{T1, T2, T3, T4} S= $$W_{T3}(y)R_{T1}(x)R_{T2}(y)W_{T3}(x)W_{T2}(x)W_{T3}(z)R_{T4}(z)W_{T4}(x)$$ $$R_{T2}(y)$$与$$W_{T3}(y)$$有写读冲突（读脏数据），画一条由点T3指向T2的有向边。 $$W_{T2}(x)$$与$$R_{T1}(x)$$有读写冲突，画一条由点T1指向T3的有向边。 $$W_{T2}(x)$$与$$R_{T1}(x)$$和$$W_{T3}(x)$$分别有冲突，画一条由点T3指向T2的有向边和T1指向T2的有向边。 以此类推，最终得到图如下： 判断是否可串行化：若前趋图有回路，则不可串行化；若没有回路，则可以串行化。 寻找等价串行调度方法：先执行入度为0的节点（事务），再将该节点（事务）及其相连边从前趋图中删除，再寻找入读为0的节点（事务）执行，反复如此，直到事务全部执行完毕。 基于锁的并发控制在实际运用中，用前面提到的方法来先验事务的可串行化并生成对应的事务执行顺序是不现实的。主要原因有以下两点： 事务集随机，不固定 不可能实现定好调度 并发控制通常的实现方法：不关心具体的调度，由DBMS制定号=好一个协议，按此协议执行事务，即可保证事务的可串行化。 加锁协议（Locking Protocol）:是上面所说的协议的一种，利用加锁实现并发控制，即在操作前对操作对象加锁。 加锁协议类型 特性 X锁（排他锁） 可读可写，其他事物不可对被加锁的数据操作，直到X锁被释放。避免了所有类型的冲突，但降低了并发度。 两阶段加锁协议（2PL协议） 所有加锁都在释放锁之前。若所有事物都遵循该协议，则它们的任何调度都是可串行化的。 （S,X）锁 与X锁相比，多了一条S锁与S锁相容，提高了并发度。 （S,U,X）锁 数据对象加了U锁后仍可被加S锁，只在最后写入时，将U锁升级为X锁。相比于X（S,X）锁，又进一步提高了并发度。 多粒度加锁或封锁 数据对象的大小可以是一张表，也可以是一个元组。 级联回退：即一事务还未结束就把锁释放了，又由于其他原因，该事务需要回退，为避免其它事务督导脏数据，要求读了和对该数据更新的操作也回退。在X锁，（S,X）锁，（S,U,X）锁中均存在该问题。 加锁协议补丁1：为避免级联回退，不管是写操作锁还是读操作锁，都应该保持到事务结束才释放。该补丁对其后的加锁协议也适用。 活锁：在（S,X）锁中，若一个数据对象被加S锁，此时若有其它事务对其加S锁，则根据相容矩阵，应该被允许，此时若有事务欲对该数据加X锁，则此X锁会被不断推迟。 加锁协议补丁2：先申请先服务，避免活锁现象造成响应时间过长，影响体验。 粒度、控制和并发度的关系：粒度越大，控制越简单，并发度越低。 多粒度加锁-锁冲突检测问题： 显式加锁：自身被加锁 隐式加锁：上级被加锁 过程： 检查本身，有无显式锁与本事务显式锁冲突。 检查其所有祖先，以防本事务显式锁与其他事务隐式锁冲突。 检查其所有子孙，以防本事务隐式锁与其他事务显式锁冲突。 简化锁冲突的检测： 三种意向锁 意向共享锁（IS锁） 意向排他锁（IX锁） 加锁时，对祖先按自上而下的顺序加意向锁。 解锁时，按自下而上的次序解锁。","link":"/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%93-%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"CV","slug":"CV","link":"/tags/CV/"},{"name":"Image","slug":"Image","link":"/tags/Image/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"}],"categories":[]}